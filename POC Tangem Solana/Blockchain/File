//
//  Blockchain.swift
//  POC Tangem Solana
//
//  Created by Ali M. on 11/09/2024.
//

import Foundation
import Solana_Swift
import Solana

func asyncWrapper<T>(call: @escaping (@escaping (Result<T, Error>) -> Void) -> Void) async throws -> T {
    try await withCheckedThrowingContinuation { continuation in
        call { result in
            switch result {
            case .success(let value):
                continuation.resume(returning: value)
            case .failure(let error):
                continuation.resume(throwing: error)
            }
        }
    }
}

public class InMemoryAccountStorage: Solana_Swift.SolanaAccountStorage {
    private var storedAccount: Account?
    
    public func save(_ account: Account) -> Result<Void, Error> {
        storedAccount = account
        return .success(())
    }
    
    public var account: Result<Account, Error> {
        if let account = storedAccount {
            return .success(account)
        } else {
            return .failure(NSError(domain: "No account stored", code: 1, userInfo: nil))
        }
    }
    
    public func clear() -> Result<Void, Error> {
        storedAccount = nil
        return .success(())
    }
}

class Blockchain {
    
    func xyz() {
        
        let secretKeyBase58 = "m2zWUh5MkVzn3aCYCxr78rTJn2z3pykcjDiStKPLxBiDcomx46BubkbYUHRmCqpxu8fcP7Tj4xit3F2w6Jfg83R"
        let secretKeyData = Data(Solana_Swift.Base58.decode(secretKeyBase58))
        
        guard let account = Account(secretKey: secretKeyData) else { return }
        
        let endpoint = Solana_Swift.RPCEndpoint.devnetSolana
        let router = NetworkingRouter(endpoints: [endpoint], apiLogger: nil)
        let accountStorage = InMemoryAccountStorage()
        let solana = Solana(router: router, accountStorage: accountStorage)
        
        let recipientPublicKey = "96fuzKSqE7tCYY3sm6SxfujhrRy5JpN3gkQqAWnsB8mm"
        
        guard let toPublicKey = Solana_Swift.PublicKey(string: recipientPublicKey) else {
            print("Invalid public key")
            return
        }
        
        let lamports: UInt64 = 1_000_000 // 0.001 SOL
        
        func getBalanceAsync(account: String) async throws -> UInt64 {
            try await asyncWrapper { completion in
                solana.api.getBalance(account: account, onComplete: completion)
            }
        }
        
        func getAccountInfoAsync<T>(account: String, decodedTo: T.Type) async throws -> Solana_Swift.BufferInfo<T> {
            try await asyncWrapper { completion in
                solana.api.getAccountInfo(account: account, decodedTo: decodedTo, onComplete: completion)
            }
        }
        
        func getLatestBlockhashAsync() async throws -> String {
            try await asyncWrapper { completion in
                solana.api.getLatestBlockhash(onComplete: completion)
            }
        }
        
        Task {
            
            do {
                
                let balance = try await getBalanceAsync(account: account.publicKey.base58EncodedString)
                print("Balance: \(balance)")
                
                let acc = try await getAccountInfoAsync(account: recipientPublicKey, decodedTo: AccountInfo.self)
                print("Recipient Balance: \(acc.lamports)")
                
                let instruction = SystemProgram.transferInstruction(
                    from: account.publicKey,
                    to: toPublicKey,
                    lamports: lamports
                )
                
                print("Before making api call")
                
                let blockhash = try await getLatestBlockhashAsync()
                
                print("Recent Blockhash: \(blockhash)")
                
                var transaction = Transaction(
                    feePayer: account.publicKey,
                    instructions: [instruction],
                    recentBlockhash: blockhash
                )
//
//                guard case .success = transaction.sign(signers: [account]) else {
//                    print("signing failed!")
//                    return
//                }
//
//                guard case .success(let serializedTransactionData) = transaction.serialize() else {
//                    print("Failed to serialize transaction!")
//                    return
//                }
//
//                let serializedTransactionBase64 = serializedTransactionData.base64EncodedString()
//
//                print("serializedTransactionBase64: \(serializedTransactionBase64)")
//
//                let transactionId = try await solana.api.sendTransaction(serializedTransaction: serializedTransactionBase64)
//
//                print("Transaction successful. ID: \(transactionId)")
                
            } catch {
                
                print("An error occurred: \(error)")
                
            }
            
        }
        
    }
    
}

